//
//  Map+Loader+Parser+H3M+Object+Town.swift
//  HoMM3SwiftUI
//
//  Created by Alexander Cyon on 2021-08-22.
//

import Foundation

public extension CaseIterable {
    static func random() -> Self {
        allCases.randomElement()!
    }
}


public extension Map {
    struct Town: Hashable, Identifiable {
        public enum ID: Hashable {
            
            /// Parsed from h3m map file
            /// Only present in version later than ROE
            case fromMapFile(UInt32)
            
            /// In case of ROE this gets generated by this code. Used to link together Map.Town.Event with their town.
            case generated(UUID)
        }
        
        public let id: ID
        public let owner: PlayerColor
        public let name: String?
        public let garrison: Army?
        public let buildings: Map.Town.Buildings
        
        public struct Spells: Hashable {
            public let obligatory: [Spell.ID]
            public let possible: [Spell.ID]
        }
        public let spells: Spells
        
        public let events: [Map.Town.Event]
        public let alignment: Alignment?
    }
}

public extension Map.Town {
    struct Buildings: Hashable {
        public let built: [Building]
        public let forbidden: [Building]
    }
}
public extension Map.Town.Buildings {
    enum Building: UInt8, Hashable, CaseIterable {
        case mageguildLevel1 = 0,
        mageguildLevel2,
        mageguildLevel3,
        mageguildLevel4,
        mageguildLevel5,
        
        tavern,
        shiphard,
        
        fort,
        citadel,
        castle,
        
        villageHall,
        townHall,
        cityHall,
        capital,
        
        marketplace,
        resourceSilo,
        blacksmith
        
        
        /// Castle: Lighthouse
        /// Rampart: Mystic pind
        /// Tower: Artifact Merchant
        /// Inferno: N/A
        /// Necropolis: Veil of darkness
        /// Dungeon: Artifact Merchant
        /// Stornghold: Escape tunnel
        /// Fortress: Cage of warlords
        /// Conflux: Artifact Merchant
        case buildingId17
        
        /// Horde buildings for upgraded creatures
        ///
        /// Castle: Grifins
        /// Rampart: Dwarfes
        /// Tower: Stone Gargoyles
        /// Inferno: IMps
        /// Necropolis: Skeletons
        /// Dungeon: Troglodytes
        /// Stornghold: Goblins
        /// Fortress: Gnolls
        /// Conflux: Pixies
        case buildingId18
        
        /// Horde buildings for upgraded creatures
        ///
        /// Castle: Royale Griffins
        /// Rampart: Battle Dwarfes
        /// Tower: Obsidian Gargoyles
        /// Inferno: Familars
        /// Necropolis: Skeleton Warrios
        /// Dungeon: Infernal Troglodytes
        /// Stornghold:Hobgoblins
        /// Fortress: Gnoll MArauders
        /// Conflux: Sprites
        case buildingId19
        
        case shipAtTheShipyard = 20

        /// Castle: Stables
        /// Rampart: Fountain of Fortune
        /// Tower: Lookout Tower
        /// Inferno: Brimstone Clouds
        /// Necropolis: Necromancy Amplifier
        /// Dungeon: Mana Vortex
        /// Stornghold: Freelancer's Guild
        /// Fortress: Glyphs Of Fear
        /// Conflux: Magic University
        case buildingId21
        
        /// Castle: Brotherhood of Sword
        /// Rampart: Dwarfen Treasure
        /// Tower: Library
        /// Inferno: Castle Gates
        /// Necropolis: Skeleton Transformer
        /// Dungeon: Portal Of Summoning
        /// Stornghold: Ballista Yard
        /// Fortress: Blood Obelisk
        /// Conflux: N/A
        case buildingId22
        
        /// Tower: Wall Of Knowledge
        /// Inferno: Order of fire
        /// Dungeon: Academy Of Battle Scholars
        /// Stornghold: Hall Of Valhalla
        /// Castle, Rampart, Necropolis, Fortress, Conflux: N/A
        case buildingId23
        
        /// Horde Buildings For Non-Upgraded Creatures:
        /// Rampart: Dendroid Guards
        /// Inferno: Hell Hounds
        /// REST: N/A
        case buildingId24
        
        /// Horde Buildings For Upgraded Creatures:
        /// Rampart: Dendroid Soldiers,
        /// Inferno: Cerberi
        /// REST: N/A
        case buildingId25
        
        case grail = 26,
        
        housesNearCityHall,
        housesNearMunicipal,
        housesNearCapitol,
        
        dwelling1,
        dwelling2,
        dwelling3,
        dwelling4,
        dwelling5,
        dwelling6,
        dwelling7,
        upgradedDwelling1,
        upgradedDwelling2,
        upgradedDwelling3,
        upgradedDwelling4,
        upgradedDwelling5,
        upgradedDwelling6,
        upgradedDwelling7
        
    }
}

public extension RandomNumberGenerator {
    mutating func randomBool() -> Bool {
        Int.random(in: 0...1, using: &self) == 0
    }
}

public extension Map.Town.Buildings.Building {

    static func `default`(
        includeFort: Bool = false,
        randomNumberGenerator: RandomNumberGenerator? = nil
    ) -> [Self]  {
        var prng = randomNumberGenerator ?? SystemRandomNumberGenerator()
        let maybeFort: Self? = includeFort ? .fort : nil
        let maybeDwelling2: Self? = prng.randomBool() ? .dwelling2 : nil
        
        return [
            maybeFort,
            .villageHall,
            .tavern,
            .dwelling1,
            maybeDwelling2
        ].compactMap({ $0 })
    }
    
}


// MARK: Parse Town
internal extension Map.Loader.Parser.H3M {
    
    
    
    func parseRandomTown(format: Map.Format, allowedSpellsOnMap: [Spell.ID]) throws -> Map.Town {
        try parseTown(format: format, faction: .random(), allowedSpellsOnMap: allowedSpellsOnMap)
    }
    
    func parseTown(format: Map.Format, faction: Faction, allowedSpellsOnMap: [Spell.ID]) throws -> Map.Town {
        
        let townID: Map.Town.ID = try format > .restorationOfErathia ? .fromMapFile(reader.readUInt32()) : .generated(UUID())
        
        let owner = try PlayerColor(integer: reader.readUInt8())
        let name: String? = try reader.readBool() ? reader.readString() : nil
        let garrison: Army? = try reader.readBool() ? parseArmyOf(size: 7, parseFormation: true) : nil
        let buildings: Map.Town.Buildings = try reader.readBool() ? parseTownWithCustomBuildings() : parseSimpleTown()
        
        
        let obligatorySpells = try format == .restorationOfErathia ? [] : parseSpellIDs()
        let possibleSpells = try parseSpellIDs(includeIfBitSet: false).filter({ allowedSpellsOnMap.contains($0) })
        
        // TODO add spells from mods.
        
        // Read castle events
        let events: [Map.Town.Event] = try reader.readUInt32().nTimes {
            let name = try reader.readString()
            let message = try reader.readString()
            let resources = try parseResources()
            let players = try parseAvailableForPlayers()
            let canBeActivatedByHuman = try format > .armageddonsBlade ? reader.readBool() : true
            let canBeActivatedByComputer = try reader.readBool()
            let firstOccurence = try reader.readUInt16()
            let nextOccurence = try reader.readUInt8()
            
            try reader.skip(byteCount: 17)
            
            // New buildings
            let buildings = try parseBuildings()
            let creatureStacks = try Creature.ID.of(faction: faction, .nonUpgradedOnly).map { creatureID in
                try CreatureStack(creatureID: creatureID, quantity: .init(reader.readUInt16()))
            }
            try reader.skip(byteCount: 4)
            
            let townEvent = Map.Event(
                message: message,
                firstOccurence: firstOccurence,
                nextOccurence: nextOccurence,
                resourcesToBeGained: resources,
                creaturesGained: .init(creatureStacks: creatureStacks),
                availableForPlayers: players,
                canBeActivatedByComputer: canBeActivatedByComputer,
                shouldBeRemovedAfterVisit: false, // is this correct?
                canBeActivatedByHuman: canBeActivatedByHuman
            )
            
            return Map.Town.Event(
                townID: townID,
                name: name,
                event: townEvent,
                buildings: buildings
            )
        }
        
        var alignment: Alignment?
        if format > .armageddonsBlade {
            alignment = try .init(integer: reader.readUInt8())
        }
        try reader.skip(byteCount: 3)
        
        return Map.Town(
            id: townID,
            owner: owner,
            name: name,
            garrison: garrison,
            buildings: buildings,
            spells: .init(
                obligatory: obligatorySpells,
                possible: possibleSpells
            ),
            events: events,
            alignment: alignment
        )
    }
}

public enum Alignment: UInt8, Hashable, CaseIterable {
    case good, evil, neutral
}

public extension Map.Town {
    struct Event: Hashable {
        public let townID: Map.Town.ID
        public let name: String
        public let event: Map.Event
        public let buildings: [Buildings.Building]
    }
}

// MARK: Private
private extension Map.Loader.Parser.H3M {
    
    func parseBuildings() throws -> [Map.Town.Buildings.Building] {
        try reader.readBitArray(byteCount: 6).prefix(Map.Town.Buildings.Building.allCases.count).enumerated().compactMap { (buildingID, isBuilt) in
           guard isBuilt else { return nil }
            return try Map.Town.Buildings.Building(integer: buildingID)
       }
    }
    
    func parseTownWithCustomBuildings() throws -> Map.Town.Buildings {
        let built = try parseBuildings()
        let forbidden = try parseBuildings()
        return .init(built: built, forbidden: forbidden)
    }
    func parseSimpleTown() throws -> Map.Town.Buildings {
        let hasFort = try reader.readBool()
        let built = Map.Town.Buildings.Building.default(includeFort: hasFort)
        return .init(built: built, forbidden: [])
    }
}
